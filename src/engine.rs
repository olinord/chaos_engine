use winit::{dpi::LogicalSize, Event, EventsLoop, WindowEvent};

use ecs::{
    manager::ChaosComponentManager,
    system::ChaosSystem
};
use rendering::render_state::RenderState;
use commands::manager::CmdManager;

pub struct ChaosEngine {
    render_state: RenderState<back::Backend>,
    events_loop: EventsLoop,
    #[allow(unused)]
    chaos_manager: ChaosComponentManager,
    systems: Vec<Box<dyn ChaosSystem>>,
    command_manager: CmdManager<back::Backend>
}

impl ChaosEngine {
    pub fn new(name: String, width: u32, height: u32) -> Result<ChaosEngine, &'static str> {
        let events_loop = EventsLoop::new();

        let wb = winit::WindowBuilder::new()
            .with_min_dimensions(
                LogicalSize::new(64.0, 64.0)
            )
            .with_max_dimensions(
                LogicalSize::new(width.into(), height.into())
            )
            .with_title(name.clone());
        let window = wb.build(&events_loop).unwrap();

        let render_state = RenderState::<back::Backend>::new(window).unwrap();

        return Ok(ChaosEngine{
            events_loop,
            render_state,
            chaos_manager: ChaosComponentManager::new(100, 10),
            systems: Vec::new(),
            command_manager: CmdManager::new()
        })
    }

    pub fn update(&mut self, delta_time: f32) -> Result<(), &'static str> {
        self.command_manager.clear_commands();

        // update the systems with the commands from inputs etc
        for system in self.systems.iter_mut() {
            // systems may or may not create render commands rendering
            system.update(delta_time, &mut self.command_manager);
        }

        Ok(())
    }

    pub fn render(&mut self) -> Result<(), &'static str> {
        // render all the render commands generated by systems
        let result = self.render_state.render(self.command_manager.get_render_commands());
        self.command_manager.clear_render_commands();
        return result;
    }

    pub fn process_events(&mut self) -> bool {
        let mut stop_engine = true;
        self.events_loop.poll_events(|event| match event {
            Event::WindowEvent {
                event: WindowEvent::CloseRequested,
                ..
            } => stop_engine = false,
            _ => stop_engine = true,
        });
        return stop_engine;
    }

    /// Adds a system to the manager and initializes it
    pub fn add_system<CS: 'static + ChaosSystem>(&mut self, system: CS) -> &Box<dyn ChaosSystem>{
        self.systems.push(Box::new(system));
        self.systems.last_mut().unwrap().initialize(&mut self.command_manager);
        self.systems.last().unwrap()
    }
}

impl Drop for ChaosEngine {
    fn drop(&mut self) {
        self.systems.clear();
    }
}

