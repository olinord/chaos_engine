use winit::{dpi::LogicalSize, EventsLoop};

use ecs::{
    manager::ChaosComponentManager,
    system::ChaosSystem
};
use rendering::render_state::RenderState;
use commands::manager::ChaosCmdManager;
use input::manager::ChaosDeviceEventManager;
use input::events::ChaosDeviceDetailedEvent;
use std::time::Instant;
use commands::cmd::ExitCmd;

pub struct ChaosEngine<'a> {
    render_state: RenderState<back::Backend>,
    events_loop: EventsLoop,
    input_manager: Option<&'a mut ChaosDeviceEventManager>,
    #[allow(unused)]
    chaos_manager: ChaosComponentManager,
    systems: Vec<Box<dyn ChaosSystem>>,
    command_manager: ChaosCmdManager<back::Backend>,
    running: bool
}

impl<'a> ChaosEngine<'a> {
    pub fn new(name: String, width: u32, height: u32) -> Result<ChaosEngine<'a>, &'static str> {
        let events_loop = EventsLoop::new();

        let wb = winit::WindowBuilder::new()
            .with_min_dimensions(
                LogicalSize::new(64.0, 64.0)
            )
            .with_max_dimensions(
                LogicalSize::new(width.into(), height.into())
            )
            .with_title(name.clone());
        let window = wb.build(&events_loop).unwrap();

        let render_state = RenderState::<back::Backend>::new(window).unwrap();

        return Ok(ChaosEngine{
            events_loop,
            render_state,
            chaos_manager: ChaosComponentManager::new(100, 10),
            systems: Vec::new(),
            command_manager: ChaosCmdManager::new(),
            input_manager: Option::None,
            running: false
        })
    }

    pub fn process_events(&mut self)  {

        let mut events = Vec::new();
        self.events_loop.poll_events(|event| match event {
            _ => events.push(ChaosDeviceDetailedEvent::from(&event) )
        });

        for type_id in self.input_manager.as_mut().unwrap().get_commands(&events) {
            self.command_manager.add_command_raw(type_id);
        }
    }

    pub fn update(&mut self, delta_time: f32) -> Result<(), &'static str> {

        self.process_events();

        // update the systems with the commands from inputs etc
        for system in self.systems.iter_mut() {
            // systems may or may not create render commands
            system.update(delta_time, &mut self.command_manager);
        }

        if self.command_manager.has_command::<ExitCmd>() {
            self.running = false;
        }

        Ok(())
    }

    pub fn render(&mut self) -> Result<(), &'static str> {
        // render all the render commands generated by systems
        let result = self.render_state.render(self.command_manager.get_render_commands());
        self.command_manager.clear_render_commands();
        return result;
    }

    /// Adds a system to the manager and initializes it
    pub fn add_system<CS: 'static + ChaosSystem>(&mut self, system: CS) -> &mut ChaosEngine<'a> {
        self.systems.push(Box::new(system));
        self.systems.last_mut().unwrap().initialize(&mut self.command_manager);
        self
    }

    pub fn set_input_manager(&mut self, input_manager: &'a mut ChaosDeviceEventManager) -> &mut ChaosEngine<'a> {
        self.input_manager = Some(input_manager);
        self
    }

    pub fn run(&mut self) -> Result<(), &'static str> {
        let mut current_time= Instant::now();
        self.running = true;
        loop {
            self.command_manager.clear_commands();
            let delta_time = current_time.elapsed().as_secs_f32();
            self.update(delta_time).unwrap();

            if !self.running {
                break;
            }

            self.render().unwrap();
            current_time = Instant::now();
        }
        return Ok(());
    }
}


impl<'a> Drop for ChaosEngine<'a> {
    fn drop(&mut self) {
        self.systems.clear();
    }
}

